# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0

import asyncio
import itertools
import time
from collections.abc import AsyncIterator
from unittest.mock import ANY
from uuid import UUID

import pytest
from fastapi import APIRouter
from fastapi import FastAPI
from fastapi import HTTPException
from fastapi import Request
from httpx import AsyncClient
from structlog.testing import capture_logs

from fastramqpi.autogenerated_graphql_client import EventSendInput
from fastramqpi.autogenerated_graphql_client import GraphQLClient
from fastramqpi.events import Event
from fastramqpi.events import GraphQLEvents
from fastramqpi.events import Listener
from fastramqpi.events import Namespace
from fastramqpi.main import FastRAMQPI
from fastramqpi.pytest_util import retry
from tests.fastramqpi.integration.conftest import Settings


@pytest.fixture
async def app() -> FastAPI:
    fastramqpi = FastRAMQPI(
        application_name="os2mo-test-integration",
        settings=Settings().fastramqpi,
        graphql_version=25,
        graphql_client_cls=GraphQLClient,
        graphql_events=GraphQLEvents(
            declare_namespaces=[
                Namespace(name="ğŸŒŒ"),
            ],
            declare_listeners=[
                Listener(
                    namespace="ğŸŒŒ",
                    user_key="test-listener",
                    routing_key="ğŸ”‘",
                    path="/handler",
                    parallelism=2,
                ),
            ],
        ),
    )
    app = fastramqpi.get_app()
    return app


@pytest.fixture
async def graphql_client(mo_client: AsyncClient) -> AsyncIterator[GraphQLClient]:
    """Authenticated GraphQL codegen client for OS2mo."""
    graphql_client = GraphQLClient(
        url=f"{mo_client.base_url}/graphql/v25",
        http_client=mo_client,
    )
    async with graphql_client as client:
        yield client


@pytest.mark.integration_test
async def test_events(
    app: FastAPI, test_client: AsyncClient, graphql_client: GraphQLClient
) -> None:
    router = APIRouter()
    received_events = []
    done = asyncio.Event()

    @router.post("/handler")
    async def handler(event: Event) -> None:
        received_events.append(event)
        done.set()

    app.include_router(router)

    await graphql_client._testing__send_event(
        input=EventSendInput(
            namespace="ğŸŒŒ",
            routing_key="ğŸ”‘",
            subject="âœ‰ï¸",
            priority=1337,
        )
    )
    await asyncio.wait_for(done.wait(), timeout=10)
    assert received_events == [
        Event(
            subject="âœ‰ï¸",
            priority=1337,
        )
    ]


@pytest.mark.integration_test
async def test_event_not_acknowledges_on_http_error(
    app: FastAPI, test_client: AsyncClient, graphql_client: GraphQLClient
) -> None:
    router = APIRouter()

    @router.post("/handler")
    async def handler(event: Event) -> None:
        raise HTTPException(status_code=404, detail="no")

    app.include_router(router)

    with capture_logs() as cap_logs:
        await graphql_client._testing__send_event(
            input=EventSendInput(
                namespace="ğŸŒŒ",
                routing_key="ğŸ”‘",
                subject="âœ‰ï¸",
            )
        )

        @retry()
        async def verify() -> None:
            assert {
                "log_level": "warning",
                "event": "HTTP status error in event callback",
                "listener": ANY,
                "n": ANY,
                "status_code": 404,
                "response": '{"detail":"no"}',
            } in cap_logs

        await verify()


@pytest.mark.integration_test
async def test_event_parallelism(
    app: FastAPI, test_client: AsyncClient, graphql_client: GraphQLClient
) -> None:
    router = APIRouter()
    barrier = asyncio.Barrier(parties=2)
    done = asyncio.Event()

    @router.post("/handler")
    async def handler(event: Event) -> None:
        # Both handlers need break the barrier at the same time to continue
        await barrier.wait()
        done.set()

    app.include_router(router)

    for subject in ("a", "b"):
        await graphql_client._testing__send_event(
            input=EventSendInput(
                namespace="ğŸŒŒ",
                routing_key="ğŸ”‘",
                subject=subject,
            )
        )

    await asyncio.wait_for(done.wait(), timeout=10)


@pytest.mark.integration_test
async def test_event_rate_limit(
    app: FastAPI, test_client: AsyncClient, graphql_client: GraphQLClient
) -> None:
    router = APIRouter()
    calls = []
    done = asyncio.Event()

    @router.post("/handler")
    async def handler(event: Event) -> None:
        calls.append(time.monotonic())
        # Request rate-limiting on the first five calls
        if len(calls) < 5:
            raise HTTPException(
                status_code=429,
                headers={"Retry-After": "5"},
            )
        # Allow immediate retrying on the next five
        elif len(calls) < 10:
            raise HTTPException(status_code=404, detail="no")
        else:
            done.set()

    app.include_router(router)

    await graphql_client._testing__send_event(
        input=EventSendInput(
            namespace="ğŸŒŒ",
            routing_key="ğŸ”‘",
            subject="âœ‰ï¸",
        )
    )

    await asyncio.wait_for(done.wait(), timeout=30)

    delays = [b - a for a, b in itertools.pairwise(calls)]
    assert all([x > 5 for x in delays[:4]]), delays  # rate-limited
    assert all([x < 5 for x in delays[4:]]), delays  # not rate-limited


@pytest.mark.integration_test
async def test_event_sets_request_id(
    app: FastAPI, test_client: AsyncClient, graphql_client: GraphQLClient
) -> None:
    router = APIRouter()
    done = asyncio.Event()

    @router.post("/handler")
    async def handler(request: Request, event: Event) -> None:
        x_request_id = request.headers["x-request-id"]
        # Check if it is a valid UUID
        UUID(x_request_id)
        done.set()

    app.include_router(router)

    await graphql_client._testing__send_event(
        input=EventSendInput(
            namespace="ğŸŒŒ",
            routing_key="ğŸ”‘",
            subject="âœ‰ï¸",
            priority=1337,
        )
    )
    await asyncio.wait_for(done.wait(), timeout=10)
