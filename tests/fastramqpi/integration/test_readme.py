# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from collections.abc import AsyncIterator
from typing import Callable
from typing import cast

import pytest
from asgi_lifespan import LifespanManager
from fastapi import FastAPI
from httpx import ASGITransport
from httpx import AsyncClient
from more_itertools import one
from starlette.types import ASGIApp

from fastramqpi.autogenerated_graphql_client import GraphQLClient
from fastramqpi.pytest_util import retry


def readme_usage_example() -> Callable[[], FastAPI]:
    from uuid import UUID

    from fastapi import APIRouter
    from fastapi import FastAPI
    from pydantic import BaseSettings

    from fastramqpi.config import Settings as FastRAMQPISettings
    from fastramqpi.events import Event
    from fastramqpi.events import GraphQLEvents
    from fastramqpi.events import Listener
    from fastramqpi.main import FastRAMQPI

    class Settings(BaseSettings):
        class Config:
            frozen = True
            env_nested_delimiter = "__"

        fastramqpi: FastRAMQPISettings

    router = APIRouter()

    @router.post("/events/person")
    async def person(event: Event[UUID]) -> None:
        print("Received event", event.subject)

    def create_fastramqpi() -> FastRAMQPI:
        settings = Settings()
        fastramqpi = FastRAMQPI(
            application_name="os2mo-example-integration",
            settings=settings.fastramqpi,
            graphql_version=25,
            graphql_client_cls=GraphQLClient,
            graphql_events=GraphQLEvents(
                declare_listeners=[
                    Listener(
                        namespace="mo",
                        user_key="my-listener",
                        routing_key="person",
                        path="/events/person",
                    ),
                ],
            ),
        )
        fastramqpi.add_context(settings=settings)

        # Add our HTTP router(s)
        app = fastramqpi.get_app()
        app.include_router(router)

        return fastramqpi

    def create_app() -> FastAPI:
        fastramqpi = create_fastramqpi()
        return fastramqpi.get_app()

    return create_app


# Integration-test fixtures from README


@pytest.fixture
async def _app() -> FastAPI:
    create_app = readme_usage_example()
    app = create_app()
    return app


@pytest.fixture
async def asgiapp(_app: FastAPI) -> AsyncIterator[ASGIApp]:
    """ASGI app with lifespan run."""
    async with LifespanManager(_app) as manager:
        yield manager.app


@pytest.fixture
async def app(_app: FastAPI, asgiapp: ASGIApp) -> FastAPI:
    """FastAPI app with lifespan run."""
    return _app


@pytest.fixture
async def test_client(asgiapp: ASGIApp) -> AsyncIterator[AsyncClient]:
    """Create test client with associated lifecycles."""
    transport = ASGITransport(app=asgiapp, client=("1.2.3.4", 123))  # type: ignore
    async with AsyncClient(
        transport=transport, base_url="http://example.com"
    ) as client:
        yield client


@pytest.fixture
async def graphql_client(app: FastAPI) -> GraphQLClient:
    """Authenticated GraphQL codegen client for OS2mo."""
    return cast(GraphQLClient, app.state.context["graphql_client"])


@pytest.mark.integration_test
async def test_readme_integration_test_example(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
) -> None:
    """NOTE: Please keep this synchronised with the README!"""
    # Precondition: The person does not already exist.
    # The auto-use fixtures should automatically ensure test isolation, but
    # sometimes, especially during local development, we might be a little too
    # fast on the ^C^C^C^C^C so pytest doesn't get a chance to clean up.
    cpr_number = "0711909893"
    employee = await graphql_client._testing__get_employee(cpr_number)
    assert employee.objects == []

    # The integration needs to be triggered to create the employee. How this is
    # done depends on the integration. We assume a /trigger/ endpoint here:
    await graphql_client._testing__create_employee(cpr_number)

    @retry()
    async def verify() -> None:
        employees = await graphql_client._testing__get_employee(cpr_number)
        employee_states = one(employees.objects)
        employee = one(employee_states.validities)
        assert employee.cpr_number == cpr_number
        assert employee.given_name == "Alice"

    await verify()
